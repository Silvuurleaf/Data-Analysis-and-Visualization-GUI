# imports/libraries
# <editor-fold desc="Imports and Libraries">
import sys
# Importing PyQt5 library to construct widgets for Graphic User Interface (GUI) application
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QLineEdit, QPushButton, QSlider, QApplication, QVBoxLayout, QHBoxLayout,
                             QApplication, QWidget, QLabel, QCheckBox, QRadioButton, QPlainTextEdit, QSizePolicy,
                             QMainWindow, QFrame, QFileDialog, QTableWidgetItem, QTableWidget, QMenu, QMessageBox,
                             QAction, QToolBar, QDialog)
from PyQt5.QtCore import Qt, QAbstractTableModel, pyqtSignal

import matplotlib

matplotlib.use("Qt5Agg")
import matplotlib.ticker as mticker

from matplotlib import pyplot as plt

plt.style.use(['ggplot'])

# Backend door for matplotlib importation required to use Pyqt with matpltlib libray
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationBar
from matplotlib.figure import Figure
from matplotlib import rcParams

rcParams.update({'figure.autolayout': True})

import csv
import pandas as pd
import numpy as np
from numpy import arange, sin, pi
import statistics

from functools import partial

import shlex
import linecache


# import inspect

# </editor-fold>

class ErrorFind():
    def PrintException(self):
        exc_type, exc_obj, tb = sys.exc_info()
        f = tb.tb_frame
        lineno = tb.tb_lineno
        filename = f.f_code.co_filename
        linecache.checkcache(filename)
        line = linecache.getline(filename, lineno, f.f_globals)
        print('EXCEPTION IN ({}, LINE {} "{}"): {}'.format(filename, lineno, line.strip(), exc_obj))


class MainWindow(QMainWindow):
    """"
            Purpose: Mainwindow screen stores majority of application widgets.
            Responsible for displaying datatable and user interaction of upload, and datamanipulation

    """

    def __init__(self):
        super(MainWindow, self).__init__()
        self.setWindowTitle("Perspective")

        # Initializes the user interface
        self.initializeUI()

        # calls our class CompareWindow and generates a copy from the blueprints
        self.compareWin = CompareWindow()

        # Adjust the max size of the window can be
        self.compareWin.resize(350, 200)
        self.compareWin.setMaximumSize(500, 250)

        self.TablePopWin = TablePopup()

        self.Debugger = ErrorFind()

    def initializeUI(self):

        # initiate list for table objects and dictionary to pair names with objects
        self.TableDB = []
        self.TableNameDB = []
        self.TableDictionary = {}


        ###set the main widget responsible for making widgets appear on scren
        self.main_widget = QWidget(self)
        self.setCentralWidget(self.main_widget)

        # CREATION OF WIDGETS GENERAL BUTTONS____________________________________________________________________________
        # <editor-fold desc="Widgets Creation CheckPoint">

        ###first file###
        # buttons associated with the first browse button
        """
            Buttons related to the first file being uploaded
        """
        self.FileNmLabel = QLabel('FileName')
        self.FileNameEdit = QLineEdit('"Filename"')
        self.FileNameEdit.setMaximumSize(200, 20)
        self.BrowseBtn = QPushButton('Browse')
        self.BrowseBtn.setMaximumSize(80, 20)

        self.OpacityLabel = QLabel('Opacity')
        self.OpacitySlider = QSlider(Qt.Horizontal)
        self.OpacitySlider.setMinimum(0)
        self.OpacitySlider.setMaximum(100)
        self.OpacitySlider.setValue(100)
        self.OpacitySlider.setTickInterval(10)
        self.OpacitySlider.setTickPosition(QSlider.TicksBelow)
        self.OpacitySlider.setMaximumSize(200, 20)

        self.ShowChkbx = QCheckBox('show')

        ###Overlay Plot###
        # checkbox to give user ability to overlay data
        self.Overlay = QCheckBox('Overlay Plots')

        self.comparison = QPushButton('Compare')
        self.comparison.setMaximumSize(80, 20)

        # </editor-fold>__________________________________________________________________________END OF WIDGET CREATION

        # Button Functionality___________________________________________________________________________________________
        # <editor-fold desc="Button Functionality">

        # connect the browse button to method ImportFile
        self.BrowseBtn.clicked.connect(self.ImportFile)

        # whenver the value of the slider is changed connect to the method OpacityVal
        self.OpacitySlider.valueChanged.connect(self.OpacityVal)

        # connect comparison button to method OpenCompare
        self.comparison.clicked.connect(self.OpenCompare)

        # </editor-fold>_____________________________________________________________________END OF BUTTON FUNCTIONALITY

        # Widget Layout_________________________________________________________________________________________________
        # <editor-fold desc="Layout">


        self.hMAIN = QHBoxLayout(self.main_widget)

        ###First File Labels###
        self.hbox2 = QHBoxLayout()
        self.hbox2.addWidget(self.FileNmLabel)
        self.hbox2.addStretch()
        self.hbox2.addWidget(self.OpacityLabel)

        ###First File Widgets###
        self.hbox3 = QHBoxLayout()
        self.hbox3.addWidget(self.FileNameEdit)
        self.hbox3.addWidget(self.BrowseBtn)
        self.hbox3.addWidget(self.OpacitySlider)
        self.hbox3.addWidget(self.ShowChkbx)

        ###OverLay###
        self.hbox5 = QHBoxLayout()
        self.hbox5.addWidget(self.Overlay)
        self.hbox5.addWidget(self.comparison)

        self.vbox = QVBoxLayout()
        self.vbox.addLayout(self.hbox2)
        self.vbox.addLayout(self.hbox3)
        self.vbox.addLayout(self.hbox5)

        self.vboxRIGHT = QVBoxLayout()

        ###SOme of these layouts are not utilized anymore
        self.HboxGraph = QHBoxLayout()
        # self.HboxGraph.addWidget(self.canvas)

        # self.vboxGraph = QVBoxLayout()
        # self.vboxGraph.addWidget(self.canvas)

        self.vboxNavBar = QVBoxLayout()
        # self.vboxNavBar.addWidget(self.NavBar)

        self.vboxData = QVBoxLayout()

        # self.vboxRIGHT.addLayout(self.vboxGraph)
        self.vboxRIGHT.addLayout(self.vbox)
        self.vboxRIGHT.addLayout(self.HboxGraph)
        self.vboxRIGHT.addLayout(self.vboxNavBar)
        self.vboxRIGHT.addLayout(self.vboxData)

        self.hMAIN.addLayout(self.vbox)
        self.hMAIN.addLayout(self.vboxRIGHT)

        # </editor-fold>

        self.show()

    def ImportFile(self):
        ###Actual importation and manipulation of Data CSV Files

        ### on click opens a dialog window asks user to pick a file from the directory and then stores the file's path.
        fileName, _ = QFileDialog.getOpenFileName(self, "QFileDialog.getOpenFileName()", "",
                                                  "(*.csv)")
        if fileName:
            print(fileName)
            self.FileNameEdit.setText(fileName)
            Data = pd.read_csv(open(fileName))
            # print(Data)

            ### removes all the statistics information from the file and reports just the raw data

            # <editor-fold desc="Data Reformatting Proccess">

            self.BaseStats = Data.drop('Nominal Value', axis=1)
            self.BaseStats.drop('median', axis=1, inplace=True)
            self.BaseStats.drop('Tolerance', axis=1, inplace=True)
            self.BaseStats.drop('mean', axis=1, inplace=True)
            self.BaseStats.drop('min', axis=1, inplace=True)
            self.BaseStats.drop('max', axis=1, inplace=True)
            self.BaseStats.drop('range', axis=1, inplace=True)
            self.BaseStats.drop('Deviation', axis=1, inplace=True)
            self.BaseStats.drop('variance', axis=1, inplace=True)
            self.BaseStats.drop('Standard Deviation', axis=1, inplace=True)
            self.BaseStats.drop('LowerBound', axis=1, inplace=True)
            self.BaseStats.drop('UpperBound', axis=1, inplace=True)
            self.BaseStats.drop('Unnamed: 0', axis=1, inplace=True)

            # print("Data has been dropped")
            # </editor-fold>

            # grabs the index as the row headers, and grabs the column index ti be the new column headers
            rowHeaders = self.BaseStats.index
            colHeaders = self.BaseStats.columns.values

            col = len(colHeaders)
            row = len(rowHeaders)

            print("table is about to be made")

            ######### PASS DATABASES THROUGH HERE!?????????!?!?!?
            # Create an instance of the table passing the data, number of rows and cols
            self.Table = CreateTable(self.BaseStats, row, col, colHeaders)

            print("Table has been made")

            ###OPEN POPUP WINDOW AND ASK FOR USER TO GIVE TABLE A NAME
            self.TablePopWin.show()
            #self.TableDB.append(self.Table)  # list stores objects of all tables made

            # First popup window when table is created signal is sent
            self.TablePopWin.TableString.connect(self.NameAssignment)
            #self.TableNameDB.append(self.Table.name)  # list stores all names of table objects

            # connecting signal created after user renames a table from the context menu
            self.Table.reNameSignal.connect(self.ReNameAdjustments)

            ###PROBLEM ONLY RUNS DICTIONARY COMMAND ONCE

            # creates dictionary for names and tables
            # self.Table.DictonarySignal.connect(self.DictionCreation)


            #self.TableDictionary = dict(zip(self.TableNameDB, self.TableDB))
            # print(
            #     "dictionary is here__________________________________________________________________________________")
            # print(self.TableDictionary)


            # connects the emitted data signal to plot initiator
            self.Table.dataSignal.connect(self.initiatePlot)



            ### TEMPORARILY DISABLED FOR TESTING PURPOSES###
            try:
                 self.compareWin.MultiBoxSignal.connect(self.initiateMultiPlot)
            except Exception as e:
                 print(e)



            # embeds the datatable into our window
            self.vboxData.addWidget(self.Table)

    def OpacityVal(self):
        OpacitySignal = pyqtSignal(int)
        print("Opacity value is being changed")

    def OpenCompare(self):
        print("opening compare window")
        self.compareWin.show()

    def initiatePlot(self, x, y, PlotVal):
        print("emit signal")
        print(x)
        print(y)
        f = createFIG()
        f.plotData(x, y, PlotVal, True)

    def initiateMultiPlot(self, tableV, rowV, PlotV):
        """
            1. Match TableName values with the key values in our TableDB
            2. When we find a  match look at that key's corresponding Table Object, and iterate
            through that objects rows and select the rows specified by rowV
            3.Call plot for those values

        """
        f = createFIG()
        print("")
        for i in tableV:
            """
                tableV: is list of strings that represent assigned tablenames [Table1, Table2, Table3]
                rowV: is a list, containing lists representing rows from corresponding Tables the user wishes to plot.
                    for example [[1,2],[3,4],[1]] means rows 1,2 from table1, rows 3,4 from table2... so on
                PlotV: is a string that is ethier "box" or "whisker" to tell what method to plot. Default right now 
                is to do a simple boxplot
            """
            print("Creating table instance")

            #Table Dictionary is setup so the names of the Tables (tableV) are the keys of the dictionary
            # and the actual table objects are referenced by these keys
            self.TableOBJ = self.TableDictionary[i]
            print("Data Type for the table object is..................{}".format(type(self.TableOBJ)))

            #for i in range(self.TableOBJ.rowCount()):
            # try:
            #     self.TableOBJ.setVerticalHeaderLabels(arange(self.TableOBJ.rowCount()))
            # except Exception as e:
            #     print(e)


            ### Test to see if I can print any output from my object###
            try:
                print(list(self.TableOBJ.currentIndex()))
            except Exception as e:
                print(e)
            for j in rowV:
                  for k in j:
                    print("selecting rows")
                    print(self.TableOBJ.selectRow(k))

                    x = self.TableOBJ.selectRow(k)
                    print("x data is here before plot command is issued................... {}".format(x))
                    y = self.TableOBJ.ColHeader
                    f.plotData(x,y,PlotV, False)


        f.plt.show()
                    # need a list of table names to compare against???
                    # everytime we make a new table add it's name to a list
                    # select table with the same name as == tableV[i]

    def DataBaseCreation(self):
        print("starting database collection of table names, objects")

        self.TableDB.append(self.Table)
        self.TableNameDB.append(self.Table.name)  # list stores all names of table objects
        self.TableDictionary = dict(zip(self.TableNameDB, self.TableDB))


    def NameAssignment(self, TableName):
        oldName = self.Table.name
        print("inside Name Assignment")
        self.Table.name = TableName

        print("adjusting table name database")
        print(self.TableNameDB)
        for i in range(len(self.TableNameDB)):
            if self.TableNameDB[i] == oldName:
                self.TableNameDB[i] = TableName
        print(self.TableNameDB)

        print(self.Table.name)

        print("Before")
        print("List of table objects........... {}".format(self.TableDB))
        print("List of table names..............{}".format(self.TableNameDB))
        print("Dictionary.......................{}".format(self.TableDictionary))

        self.DataBaseCreation()

        print("List of table objects........... {}".format(self.TableDB))
        print("List of table names..............{}".format(self.TableNameDB))
        print("Dictionary.......................{}".format(self.TableDictionary))

        # self.DictionCreation() #COULD IS PROBLEMATIC_____________________________________________________________

    def ReNameAdjustments(self, oldName, newName):
        print("rename has been called from the context menu on the QtableWidget")
        print("table name database before for loop")
        print(self.TableNameDB)
        for i in range(len(self.TableNameDB)):
            if self.TableNameDB[i] == oldName:
                self.TableNameDB[i] = newName
        print(self.TableNameDB)

        print("Before")
        print("List of table objects........... {}".format(self.TableDB))
        print("List of table names..............{}".format(self.TableNameDB))
        print("Dictionary.......................{}".format(self.TableDictionary))

        self.DataBaseCreation()

        print("List of table objects........... {}".format(self.TableDB))
        print("List of table names..............{}".format(self.TableNameDB))
        print("Dictionary.......................{}".format(self.TableDictionary))

class CreateTable(QTableWidget):
    dataSignal = pyqtSignal(list, np.ndarray, str)  # Signal Emitted to send x,y data for plotting
    reNameSignal = pyqtSignal(str, str)  # signal to send the previous name of the table and the assigned new name
    DictionarySignal = pyqtSignal()  # supposedly the signal to run dictionary re-creation

    # Maybe add boolean to dictionary signal


    def __init__(self, Data, row, col, colHeaders):
        super(CreateTable, self).__init__()

        print("Start initialization: Table Creation is underway LINE:324")

        # initiate a name to give to the table before the user assigns it a name.
        self.name = "temporary name"

        self.setSelectionBehavior(self.SelectRows)

        self.ColHeader = colHeaders
        self.setRowCount(row)
        self.setColumnCount(col)
        self.data = Data
        self.setHorizontalHeaderLabels(colHeaders)

        print("Right Before for loop to assign data to QTableWidget")

        n = len(Data)
        m = len(colHeaders)

        for i in range(n):
            DataValues = self.data.iloc[i, :]
            print("values are {}".format(DataValues))
            # m = len(values)
            ConvertedVals = pd.to_numeric(DataValues)

            ValList = DataValues.values.tolist()
            print(ValList)

            for j in range(0, m):
                self.item = QTableWidgetItem(str(round(ValList[j], 5)))
                # print("{}, {}".format(i, j))
                self.setItem(i, j, self.item)

    def contextMenuEvent(self, event):

        menu = QMenu(self)
        graphAction = menu.addAction("Graph")  # Boxplt

        scatterAction = menu.addAction("Scatter Plot")
        checkAttributesAction = menu.addAction("Table Attributes")
        ###checkAttributes open a settings-esque window


        ReNameAction = menu.addAction("Rename")
        printNameAction = menu.addAction("Name?")
        printAction = menu.addAction("Print Row")
        quitAction = menu.addAction("Close Table")

        action = menu.exec_(self.mapToGlobal(event.pos()))

        if action == quitAction:
            self.deleteLater()
        elif action == printAction:
            self.selected = self.selectedItems()
            n = len(self.selected)
            print("n is {}".format(n))
            for i in range(n):
                self.selected[i] = str(self.selected[i].text())
            for i in range(n):
                self.selected[i] = float(self.selected[i])
            print(self.selected)

        ###Attribute Naming related actions###
        elif action == ReNameAction:
            self.openPop = TablePopup()
            self.openPop.show()
            self.openPop.TableString.connect(self.NameAssignV2)

        elif action == printNameAction:
            print(self.name)

        ###GRAPHING COMMANDS###
        elif action == graphAction:
            self.selected = self.selectedItems()
            n = len(self.selected)
            for i in range(n):
                self.selected[i] = str(self.selected[i].text())
            for i in range(n):
                self.selected[i] = float(self.selected[i])
            print("right before plotter called")

            # self.Graph = Plotter(self.selected, self.ColHeader)
            print(type(self.selected), type(self.ColHeader))

            # self.plotbtn.clicked.connect(partial(self.initiatePlot, xdata, ydata))
            self.PlotVal = "box"
            self.dataSignal.emit(self.selected, self.ColHeader, self.PlotVal)

        elif action == scatterAction:
            self.selected = self.selectedItems()
            n = len(self.selected)
            for i in range(n):
                self.selected[i] = str(self.selected[i].text())
            for i in range(n):
                self.selected[i] = float(self.selected[i])
            print("right before plotter called")

            # self.Graph = Plotter(self.selected, self.ColHeader)
            print(type(self.selected), type(self.ColHeader))

            self.PlotVal = "scatter"
            self.dataSignal.emit(self.selected, self.ColHeader, self.PlotVal)

        else:
            print("u clicked something other than quit")

    def NameAssignV2(self, TableName):
        currentName = self.name
        print("inside Name Assignment VERSION 2")
        self.name = TableName
        print(self.name)

        self.reNameSignal.emit(currentName, self.name)
        self.DictionarySignal.emit()  # COULD BE PROBLEMATIC_____________________________
        # for i in range(len(self.TableNameDB)):
        #     if self.TableNameDB[i] == currentName:
        #         self.TableNameDB[i] = TableName

    def NameChange(self, string):
        print("name change initiate")
        self.name = string
        print("table name is {}".format(self.name))

    ### WORK IN PROGRESS
    def MultiGraphHandler(self):
        self.connect.MultiBoxSignal()
        print("idk how to connect this signal")


class TablePopup(QMainWindow):
    """
        The purpose of TablePopup class is for when the user creates a table. We want to be able to identify
        this table later on so we want the user to give it a sepcifc name.
        TablePopup prompts the user with a small dialog box and asks for a some name to be inputted.

        The name is then emitted and the CreateTable class handles the string assigning it as its new name

    """

    TableString = pyqtSignal(str)

    def __init__(self):
        super(TablePopup, self).__init__()

        self.setWindowTitle("Table Properties")

        self.initTablePop()

    def initTablePop(self):
        self.main_widget = QWidget(self)
        self.setCentralWidget(self.main_widget)

        # submits user input when enter button is clicked
        self.enterBTN = QPushButton("Enter")
        self.enterBTN.clicked.connect(self.submitName)
        self.enterBTN.setMaximumSize(50, 20)

        # Accepts user input and connects to submit name code if the user hits enter after
        self.editName = QLineEdit("Enter Table Name")
        self.editName.setMaximumSize(100, 20)
        self.editName.returnPressed.connect(self.enterBTN.click)

        ###LAYOUT###
        self.Main = QVBoxLayout(self.main_widget)

        self.hor1 = QHBoxLayout()
        self.hor1.addWidget(self.editName)
        self.hor1.addWidget(self.enterBTN)

        self.Main.addLayout(self.hor1)

    def submitName(self):
        # Once enter is hit or enter button is clicked then the signal is emitted containg the new name
        print("name has been changed")
        TableName = self.editName.text()
        print(TableName)
        self.TableString.emit(TableName)

        # after submittion popupbox closes
        self.close()


class CompareWindow(QMainWindow):
    """
        Creates the comparison window that will be opened when the user clicks the compare button.

        Purpose: Used to create plots using multiple trend reports from different imported spreadsheets
        The user will type in names of the data tables and their corresponding row numbers which they wish
        to plot from.
    """

    MultiBoxSignal = pyqtSignal(list, list, str)

    def __init__(self):
        super(QMainWindow, self).__init__()
        self.setWindowTitle("Perspective - MultiGraph Window")

        # initialize Compare User Interface
        self.CompareUI()

    def CompareUI(self):
        print("initialize widgets")

        # Creates the mainwidget to hold/display all other widgets on
        self.main_widget = QWidget(self)
        self.setCentralWidget(self.main_widget)

        # Creating descriptor labels
        self.TableHeader = QLabel("Tables")
        self.RowHeader = QLabel("Row Selection")

        ###MUST FOLLOW FORMAT EXACTLY### Table name must be a string, no symbols
        # string is the automatic default no matter what no plans to make a conversion for integers
        self.Instructions = QLabel(
            'Input Format is as Follows... "Table Name", "row, numbers, seperated, with, commas" ')

        """
        These aren't a QtableWidget these are QlineEdits that ask the user to input which table and which rows they
        want to pull data from. Quotations are neccessary. 

        *Quotations allow function shelex.split() to split on quotations and then store in a list

        """
        self.TableRowEntry1 = QLineEdit(' "Table", "Rows Numbers" ')
        self.TableRowEntry2 = QLineEdit(' "Table", "Rows Numbers" ')
        self.TableRowEntry3 = QLineEdit(' "Table", "Rows Numbers" ')
        self.TableRowEntry4 = QLineEdit(' "Table", "Rows Numbers" ')
        self.TableRowEntry5 = QLineEdit(' "Table", "Rows Numbers" ')



        ##Create buttons for box and scatter plot
        self.BoxPlot = QPushButton("Box Plot")
        self.ScatterPlot = QPushButton("Scatter Plot")

        """
        This is prob not going to work Overload???
        
        does the on enter need to be for every btn????
        """
        self.TableRowEntry1.returnPressed.connect(self.BoxPlot.click)
        self.TableRowEntry2.returnPressed.connect(self.BoxPlot.click)
        self.TableRowEntry3.returnPressed.connect(self.BoxPlot.click)
        self.TableRowEntry4.returnPressed.connect(self.BoxPlot.click)
        self.TableRowEntry5.returnPressed.connect(self.BoxPlot.click)


        # <editor-fold desc="Error msg feedback">

        ###WORK IN PROGRESS: Error msgs and error handling###
        self.ErrorMsg = QMessageBox()
        self.ErrorMsg.setText("Nothing for now")
        self.ErrorMsg.setInformativeText("This is additional information")
        self.ErrorMsg.setWindowTitle("Error Message")
        self.ErrorMsg.setDetailedText("The details are as follows:")

        # </editor-fold>

        # Initial values (TEST VALUES)
        self.Label = QLabel("Empty right now")
        self.text = "initial string"

        """
            Currently these values are just the strings from default setting of the QlineEdit
            .text() grabs whatever text is inside the QLineEdits, which right now is ' "Table", "Rows Numbers" '
        """
        self.Entry1 = self.TableRowEntry1.text()
        self.Entry2 = self.TableRowEntry2.text()
        self.Entry3 = self.TableRowEntry3.text()
        self.Entry4 = self.TableRowEntry4.text()
        self.Entry5 = self.TableRowEntry5.text()

        """
            Checks to see if the text in the QlineEdit has changed and if it has it passes the arguments a string, and a
            number representing which QlineEdit was modified, 1-5 descending order.
            partial allows for the passing of multiple arguments through, what is normally only one

        """
        self.TableRowEntry1.textChanged[str].connect(partial(self.onChanged, entryNum=1))
        self.TableRowEntry2.textChanged[str].connect(partial(self.onChanged, entryNum=2))
        self.TableRowEntry3.textChanged[str].connect(partial(self.onChanged, entryNum=3))
        self.TableRowEntry4.textChanged[str].connect(partial(self.onChanged, entryNum=4))
        self.TableRowEntry5.textChanged[str].connect(partial(self.onChanged, entryNum=5))

        print("About to call plotting functions")
        ###Takes the Entrys that have been made connects it my my methods Box/ScatterPlotCall###
        self.BoxPlot.clicked.connect(self.BoxPlotCall)
        self.ScatterPlot.clicked.connect(self.ScatterPlotCall)

        ###LAYOUT###
        # <editor-fold desc="Layout">
        self.vboxMain = QVBoxLayout(self.main_widget)
        self.VboxCOMP1 = QVBoxLayout()

        self.vboxMain.addLayout(self.VboxCOMP1)

        self.Header = QHBoxLayout()
        self.Header.addWidget(self.TableHeader)
        self.Header.addWidget(self.RowHeader)

        self.subHeader = QHBoxLayout()
        self.subHeader.addStretch()
        self.subHeader.addWidget(self.Instructions)

        self.hboxCOMP1 = QHBoxLayout()
        # self.hboxCOMP1.addStretch()
        self.hboxCOMP1.addWidget(self.TableRowEntry1)
        self.hboxCOMP1.addStretch()

        self.hboxCOMP2 = QHBoxLayout()
        # self.hboxCOMP2.addStretch()
        self.hboxCOMP2.addWidget(self.TableRowEntry2)
        self.hboxCOMP2.addStretch()

        self.hboxCOMP3 = QHBoxLayout()
        # self.hboxCOMP3.addStretch()
        self.hboxCOMP3.addWidget(self.TableRowEntry3)
        self.hboxCOMP3.addStretch()

        self.hboxCOMP4 = QHBoxLayout()
        # self.hboxCOMP3.addStretch()
        self.hboxCOMP4.addWidget(self.TableRowEntry4)
        self.hboxCOMP4.addStretch()

        self.hboxCOMP5 = QHBoxLayout()
        # self.hboxCOMP3.addStretch()
        self.hboxCOMP5.addWidget(self.TableRowEntry5)
        self.hboxCOMP5.addStretch()

        self.hboxPlotBtns = QHBoxLayout()
        self.hboxPlotBtns.addWidget(self.BoxPlot)
        self.hboxPlotBtns.addWidget(self.ScatterPlot)
        self.hboxPlotBtns.addStretch()

        self.hboxRAND = QHBoxLayout()
        self.hboxRAND.addWidget(self.Label)

        ### ADD TO PAGE ###
        self.VboxCOMP1.addLayout(self.Header)
        self.VboxCOMP1.addLayout(self.subHeader)
        self.VboxCOMP1.addLayout(self.hboxCOMP1)
        self.VboxCOMP1.addLayout(self.hboxCOMP2)
        self.VboxCOMP1.addLayout(self.hboxCOMP3)
        self.VboxCOMP1.addLayout(self.hboxCOMP4)
        self.VboxCOMP1.addLayout(self.hboxCOMP5)
        self.VboxCOMP1.addLayout(self.hboxPlotBtns)
        # self.VboxCOMP1.addLayout(self.hboxRAND)
        # </editor-fold>

    def onChanged(self, text, entryNum):
        """
            Purpose: checks to see which QlineEdit was modfied using the QlineEdit number
            takes the text in the LineEdit and defines it as the User's entry text
        """

        if entryNum == 1:
            self.text = text
            userIN = str(self.text)
            self.Entry1 = userIN
        elif entryNum == 2:
            self.text = text
            userIN = str(self.text)
            self.Entry2 = userIN
        elif entryNum == 3:
            self.text = text
            userIN = str(self.text)
            self.Entry3 = userIN
        elif entryNum == 4:
            self.text = text
            userIN = str(self.text)
            self.Entry4 = userIN
        elif entryNum == 5:
            self.text = text
            userIN = str(self.text)
            self.Entry5 = userIN

        else:
            print("something was passed")
            pass

        # List with all possible entries looking at a maximum of 5???
        # possibly problematic in case future iterations want to include more entries
        ###Create a list containg all entries the user has input###
        self.ALLentries = [self.Entry1, self.Entry2, self.Entry3, self.Entry4, self.Entry5]

    def BoxPlotCall(self):

        # runs method CheckEntries to see which LineEdits were actually modfied, returns booleans to expediate the next proccess
        self.CheckEntries()

        # List of truth values see which lineEdits the user has changed
        UserInputList = [self.userInput, self.userInput2, self.userInput3, self.userInput4, self.userInput5]

        # List to save index for the tables whos QlineEdits have changed
        MutableList = []

        """
            Enumerate goes through a list and creates an order pair with the item and its index.
            For example the list [apple, grape, berry], once enumerated, becomes [(0, apple),(1, grape),(2, berry)]
        """

        UserInputList = list(enumerate(UserInputList))
        print("enumerated userinput list")
        print(UserInputList)

        ###For loop runs through our list of booleans and checks to see which ones are True ('modifed from user inputting something')
        for index, item in enumerate(UserInputList, start=0):
            print("item is .... {}".format(item))
            # print([item[1] for i in UserInputList])

            # checks the ordered pair and look at the second item in the pair to check the boolean
            if item[1] == True:
                print(item)
                # appends the index for that item to a list to be referenced later on
                MutableList.append(index)

                ###Print Statements for debugging###
                print("printing index ... {}".format(index))
                print("printing mutablelist ... ")
                print(MutableList)
            else:
                pass

        # Want to call for all tables that have been changed
        # We have the numbers now we want to attach those to our variable and call it as such

        print("Parsing is about to begin")

        ParsedList = []  # initiate a list to store all parsed strings from the QlineEdits
        self.RowNumList = []  # initiate a list to store Row numbers
        self.TableList = []  # initiate a list to store Table Names

        """
            For loop parses string and stores parsed strings into two seperate lists
            one list for row numbers and the other for the table names
        """
        i = 0
        for i in range(len(MutableList)):
            print("mutable list is as follows...")
            print(MutableList)
            print("Inisde parse loop, i value is {}".format(i))
            print(self.ALLentries[MutableList[i]])
            """
                shelex.split() is a unique parser in that it seperates based on quotations (" ")
                This used to seperate the Table Names, and Row Numbers since both are surrounded by quotations
            """
            ParsedString = shlex.split(self.ALLentries[MutableList[i]])
            print("parsed string is ..... {}".format(ParsedString))
            print(type(ParsedString))

            # attach parsed string to our list
            ParsedList.append(ParsedString)
            print(ParsedList)

            print("second element of string ... {}".format(ParsedList[i][1]))

            ###Selecting the row numbers###_____________________________________________________________________________

            # further split the nested list using the fact each item is sepereated with a comma
            RowVals = ParsedList[i][1].split(',')
            print("ROWS TO BE SELECTED are as follows...")
            print(RowVals)
            print("right before mapping")

            # convert the strings into integers
            RowVals = list(map(int, RowVals))

            print("Row Values after mapping has taken place")
            print(RowVals)
            self.RowNumList.append(RowVals)
            print(self.RowNumList)

            # DEBUGGING STATEMENTS TO CHECK OUTPUT
            # print(self.RowNumList)
            # print(type(self.RowNumList[0]))


            ###Selecting the Table Number###____________________________________________________________________________
            # Methodology is similar to RowVal collection above. Follows almost same proccess

            print("Right before appending things to Table List")
            TableEntry = ParsedList[i][0].split(',')

            print("Table list is as follows")
            print(TableEntry)
            print(type(TableEntry[0]))
            print("first element of table entry is .... {}".format(TableEntry[0]))

            """
                Error Handling depending on user input if the table name is a number vs a string we have to
                approach the problem differently. First checks to see if the string can be converted to an integer else
                it just continues on as a string.

                POSSIBLE BUG: if it can be converted to integer might skip all below code and just end. ErrorHandling W.I.P.
            """

            TableVal = (TableEntry[0])
            self.TableList.append(TableVal)
            print("current counter is ............... {}".format(i))

        # string value so we know when we call plot to do a boxplot
        self.PlotCompareVal = "box"

        ###output check###
        print("Parsedstring list is here .......... {}".format(ParsedList))
        print("Row numbers list is as follows.... {}".format(self.RowNumList))

        print("Table List is as follows....{}".format(self.TableList))
        print(self.TableList)

        # This is the data for which Table Names and which Rows need to be plotted
        print(type(self.RowNumList))
        print(type(self.TableList))

        ###SIGNAL EMMITTION W.I.P.
        self.MultiBoxSignal.emit(self.TableList, self.RowNumList, self.PlotCompareVal)

    def CheckEntries(self):
        """
            Purpose
            Check to see which entries have been modified returns True if user input is detected
            The check is run by comparing the current state (string) to the default string which is...
            "Table", "Rows Numbers"
            QUOTATIONS ARE NECCESSARY in order to parse user input later on with shelex() method

        """
        if self.Entry1 == ' "Table", "Rows Numbers" ':
            self.userInput = False
        else:
            self.userInput = True

        if self.Entry2 == ' "Table", "Rows Numbers" ':
            self.userInput2 = False
        else:
            self.userInput2 = True

        if self.Entry3 == ' "Table", "Rows Numbers" ':
            self.userInput3 = False
        else:
            self.userInput3 = True

        if self.Entry4 == ' "Table", "Rows Numbers" ':
            self.userInput4 = False
        else:
            self.userInput4 = True

        if self.Entry5 == ' "Table", "Rows Numbers" ':
            self.userInput5 = False
        else:
            self.userInput5 = True

    def ScatterPlotCall(self):
        print("scatter plot called")
        ### W.I.P###


class createFIG():
    """
        Purpose: create the base figure for data to be plotted on.
        1. Inheritance/initalization
        2. defining figure and axes
        3. Plotting method
    """

    ### 1).Inheritance/initialization ###
    def __init__(self):
        super(createFIG, self).__init__()

        # 2). Figure/axes defined
        self.figure = plt.figure()  # creates a blank figure to plot data on
        """
        'self.figure.add_subplot(111)'
        defines the number and position of subplots first two numbers are total number of plots on grid.
        For example 2x2 indicates total of 4 plots. Last number indicates the acutal plot number. For example 223 means
        there are four plots and we are looking at the third plot of the 4
        """
        self.axes = self.figure.add_subplot(111)

        # define axes headers
        self.axes.set_xlabel('x label')
        self.axes.set_ylabel('y label')

    # 3). Plotting Method
    """
        Purpose: differentiate which type of graph should be plotted depending on user input
        Takes arguments(List, List, str)
    """

    def plotData(self, xdata, ydata, PlotVal, show):
        # Debugging Statements
        print("plotting")
        #print("elements data type of list x is {}".format(type(xdata[1])))
        #print("elements data type of list y is {}".format(type(ydata[1])))
        #print("PlotVal data type is {}".format(type(PlotVal)))

        ###Superficial Touches###

        self.axes.grid()  # add a grid to plot

        # Plots boxplots
        if PlotVal == "box":
            print("inside PlotVal = box")
            self.x = xdata

            print("x data is here .......{}".format(self.x))
            try:
                print("data type of static x is {}".format(type(self.x[1])))
            except:
                self.Debugger.PrintException()

            self.axes.boxplot(self.x)
            self.axes.grid()
        # Plots ScatterPlots
        elif PlotVal == "scatter":

            self.x = xdata
            self.y = ydata
            print("about to assign n")

            n = len(self.y)
            print(n)
            print(self.x)
            print(self.y)

            # Creates 1 to n many points along our x-axis for each piece of data we will plot
            self.NumTicks = np.arange(n)
            print(self.NumTicks)

            # sets ticks 1-n as x-axis
            self.axes.set_xticks(self.NumTicks)
            print("ticks have been created ")

            # sets our table headers as the x-axis labels for our datapoints, and rotates to look better
            self.axes.set_xticklabels(self.y, rotation=60)
            print("strings have been set as labels")

            # creates scatter plot
            self.axes.scatter(self.NumTicks, self.x)
            self.axes.grid()
            # self.axes.plt.tight_layout()

        if show == True:
            plt.show()
        else:
            pass
        print("graph appears")


def main():
    # main loop
    app = QApplication(sys.argv)

    # instance
    window = MainWindow()
    window.show()
    # appWindow = MainWindow()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
